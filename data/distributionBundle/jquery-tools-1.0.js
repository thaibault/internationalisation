// Generated by CoffeeScript 1.9.0

/*
[Project page](http://torben.website/jQuery-tools)

This module provides common reusable logic for every non trivial jQuery plugin.

Copyright Torben Sickert 16.12.2012

License
-------

This library written by Torben Sickert stand under a creative commons naming
3.0 unported license. see http://creativecommons.org/licenses/by/3.0/deed.de

Extending this module
---------------------

For conventions see require on https://github.com/thaibault/require

Author
------

t.sickert["~at~"]gmail.com (Torben Sickert)

Version
-------

1.0 stable
 */

(function() {
  var main,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  main = function($) {
    var Tools, nativePropFunction;
    Tools = (function() {

      /*
          This plugin provides such interface logic like generic controller
          logic for integrating plugins into $, mutual exclusion for
          depending gui elements, logging additional string, array or
          function handling. A set of helper functions to parse option
          objects dom trees or handle events is also provided.
       */

      /*
          **self {Tools}**
          Saves a reference to this class useful for introspection.
       */
      Tools.prototype.self = Tools;


      /*
          **keyCode {Object}**
          Saves a mapping from key codes to their corresponding name.
       */

      Tools.prototype.keyCode = {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
      };


      /*
          Lists all known abbreviation for proper camel case to delimited
          and back conversion.
       */

      Tools.prototype.abbreviations = ['html', 'id', 'url', 'us', 'de', 'api', 'href'];


      /*
          **transitionEndEventNames {String}**
          Saves a string with all css3 browser specific transition end event
          names.
       */

      Tools.prototype.transitionEndEventNames = 'transitionend webkitTransitionEnd oTransitionEnd ' + 'MSTransitionEnd';


      /*
          **animationEndEventNames {String}**
          Saves a string with all css3 browser specific animation end event
          names.
       */

      Tools.prototype.animationEndEventNames = 'animationend webkitAnimationEnd oAnimationEnd MSAnimationEnd';


      /*
          **maximalsupportedinternetexplorerversion {String}**
          Saves currently minimal supported internet explorer version.
       */

      Tools.prototype.maximalSupportedInternetExplorerVersion = (function() {

        /*Returns zero if no internet explorer present. */
        var div, version, _i;
        div = document.createElement('div');
        for (version = _i = 0; _i < 9; version = ++_i) {
          div.innerHTML = '<!' + ("--[if gt IE " + version + "]><i></i><![e") + 'ndif]-' + '->';
          if (!div.getElementsByTagName('i').length) {
            break;
          }
        }
        if (!version) {
          if (window.navigator.appVersion.indexOf('MSIE 10') !== -1) {
            return 10;
          } else if (window.navigator.userAgent.indexOf('Trident') !== -1 && window.navigator.userAgent.indexOf('rv:11') !== -1) {
            return 11;
          }
        }
        return version;
      })();


      /*
          **_consoleMethods {String[]}**
          This variable contains a collection of methods usually binded to
          the console object.
       */

      Tools.prototype._consoleMethods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];


      /*
          **_javaScriptDependentContentHandled {Boolean}**
          Indicates weather javaScript dependent content where hide or shown.
       */

      Tools.prototype._javaScriptDependentContentHandled = false;


      /*
          **__tools__ {Boolean}**
          Indicates if an instance was derived from this class.
       */

      Tools.prototype.__tools__ = true;


      /*
          **__name__ {String}**
          Holds the class name to provide inspection features.
       */

      Tools.prototype.__name__ = 'Tools';

      function Tools(_at_$domNode, _at__options, _at__defaultOptions, _at__locks) {
        var method, _i, _len, _ref;
        this.$domNode = _at_$domNode != null ? _at_$domNode : null;
        this._options = _at__options != null ? _at__options : {};
        this._defaultOptions = _at__defaultOptions != null ? _at__defaultOptions : {
          logging: false,
          domNodeSelectorPrefix: 'body',
          domNode: {
            hideJavaScriptEnabled: '.tools-hidden-on-javascript-enabled',
            showJavaScriptEnabled: '.tools-visible-on-javascript-enabled'
          }
        };
        this._locks = _at__locks != null ? _at__locks : {};

        /*
            This method should be overwritten normally. It is triggered if
            current object is created via the "new" keyword.
        
            The dom node selector prefix enforces to not globally select
            any dom nodes which aren't in the expected scope of this
            plugin. "{1}" will be automatically replaced with this plugin
            name suffix ("incrementer"). You don't have to use "{1}" but it
            can help you to write code which is more reconcilable with the
            dry concept.
        
            **returns {$.Tools}** Returns the current instance.
         */
        _ref = this._consoleMethods;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          method = _ref[_i];
          if (window.console == null) {
            window.console = {};
          }
          if (window.console[method] == null) {
            console[method] = $.noop();
          }
        }
        if (!this.self.prototype._javaScriptDependentContentHandled) {
          this.self.prototype._javaScriptDependentContentHandled = true;
          $(this._defaultOptions.domNodeSelectorPrefix + ' ' + this._defaultOptions.domNode.hideJavaScriptEnabled).filter(function() {
            return !$(this).data('javaScriptDependentContentHide');
          }).data('javaScriptDependentContentHide', true).hide();
          $(this._defaultOptions.domNodeSelectorPrefix + ' ' + this._defaultOptions.domNode.showJavaScriptEnabled).filter(function() {
            return !$(this).data('javaScriptDependentContentShow');
          }).data('javaScriptDependentContentShow', true).show();
        }
        return this;
      }

      Tools.prototype.destructor = function() {

        /*
            This method could be overwritten normally. It acts like a
            destructor.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        this.off('*');
        return this;
      };

      Tools.prototype.initialize = function(options) {
        if (options == null) {
          options = {};
        }

        /*
            This method should be overwritten normally. It is triggered if
            current object was created via the "new" keyword and is called
            now.
        
            **options {Object}**  - options An options object.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        this._options = $.extend(true, {}, this._defaultOptions, this._options, options);
        this._options.domNodeSelectorPrefix = this.stringFormat(this._options.domNodeSelectorPrefix, this.stringCamelCaseToDelimited(this.__name__));
        return this;
      };

      Tools.prototype.controller = function(object, parameter, $domNode) {
        if ($domNode == null) {
          $domNode = null;
        }

        /*
            Defines a generic controller for $ plugins.
        
            **object {Object|String}** - The object or class to control. If
                                         "object" is a class an instance
                                         will be generated.
        
            **parameter {Arguments}**  - The initially given arguments
                                         object.
        
            **returns {Mixed}**        - Returns whatever the initializer
                                         method returns.
         */
        parameter = this.argumentsObjectToArray(parameter);
        if (object.__name__ == null) {
          object = new object($domNode);
          if (object.__tools__ == null) {
            object = $.extend(true, new Tools, object);
          }
        }
        if (($domNode != null) && !$domNode.data(object.__name__)) {
          $domNode.data(object.__name__, object);
        }
        if (object[parameter[0]] != null) {
          return object[parameter[0]].apply(object, parameter.slice(1));
        } else if (!parameter.length || $.type(parameter[0]) === 'object') {

          /*
              If an options object or no method name is given the
              initializer will be called.
           */
          return object.initialize.apply(object, parameter);
        }
        return $.error(("Method \"" + parameter[0] + "\" does not exist on $-extension ") + (object.__name__ + "\"."));
      };

      Tools.prototype.acquireLock = function(description, callbackFunction, autoRelease) {
        var wrappedCallbackFunction;
        if (autoRelease == null) {
          autoRelease = false;
        }

        /*
            Calling this method introduces a starting point for a critical
            area with potential race conditions. The area will be binded to
            given description string. So don't use same names for different
            areas.
        
            **description {String}**        - A short string describing the
                                              critical areas properties.
        
            **callbackFunction {Function}** - A procedure which should only
                                              be executed if the
                                              interpreter isn't in the
                                              given critical area. The lock
                                              description string will be
                                              given to the callback
                                              function.
        
            **autoRelease {Boolean}**       - Release the lock after
                                              execution of given callback.
        
            **returns {$.Tools}**           - Returns the current instance.
         */
        wrappedCallbackFunction = (function(_this) {
          return function(description) {
            callbackFunction(description);
            if (autoRelease) {
              return _this.releaseLock(description);
            }
          };
        })(this);
        if (this._locks[description] != null) {
          this._locks[description].push(wrappedCallbackFunction);
        } else {
          this._locks[description] = [];
          wrappedCallbackFunction(description);
        }
        return this;
      };

      Tools.prototype.releaseLock = function(description) {

        /*
            Calling this method  causes the given critical area to be
            finished and all functions given to "this.acquireLock()" will
            be executed in right order.
        
            **description {String}** - A short string describing the
                                       critical areas properties.
        
            **returns {$.Tools}**    - Returns the current instance.
         */
        if (this._locks[description] != null) {
          if (this._locks[description].length) {
            this._locks[description].shift()(description);
          } else {
            delete this._locks[description];
          }
        }
        return this;
      };

      Tools.prototype.mouseOutEventHandlerFix = function(eventHandler) {

        /*
            This method fixes an ugly javaScript bug. If you add a mouseout
            event listener to a dom node the given handler will be called
            each time any dom node inside the observed dom node triggers a
            mouseout event. This methods guarantees that the given event
            handler is only called if the observed dom node was leaved.
        
            **eventHandler {Function}** - The mouse out event handler.
        
            **returns {Function}**      - Returns the given function
                                          wrapped by the workaround logic.
         */
        var self;
        self = this;
        return function(event) {
          var relatedTarget;
          relatedTarget = event.toElement;
          if (event.relatedTarget) {
            relatedTarget = event.relatedTarget;
          }
          while (relatedTarget && relatedTarget.tagName !== 'BODY') {
            if (relatedTarget === this) {
              return;
            }
            relatedTarget = relatedTarget.parentNode;
          }
          return eventHandler.apply(self, arguments);
        };
      };

      Tools.prototype.log = function() {
        var additionalArguments, avoidAnnotation, force, level, message, object, _ref;
        object = arguments[0], force = arguments[1], avoidAnnotation = arguments[2], level = arguments[3], additionalArguments = 5 <= arguments.length ? __slice.call(arguments, 4) : [];
        if (force == null) {
          force = false;
        }
        if (avoidAnnotation == null) {
          avoidAnnotation = false;
        }
        if (level == null) {
          level = 'info';
        }

        /*
            Shows the given object's representation in the browsers
            console if possible or in a standalone alert-window as
            fallback.
        
            **object {Mixed}**            - Any object to print.
        
            **force {Boolean}**           - If set to "true" given input
                                            will be shown independently
                                            from current logging
                                            configuration or interpreter's
                                            console implementation.
        
            **avoidAnnotation {Boolean}** - If set to "true" given input
                                            has no module or log level
                                            specific annotations.
        
            **level {String}**            - Description of log messages
                                            importance.
        
            Additional arguments are used for string formating.
        
            **returns {$.Tools}**         - Returns the current instance.
         */
        if (this._options.logging || force || (level === 'error' || level === 'critical')) {
          if (avoidAnnotation) {
            message = object;
          } else if ($.type(object) === 'string') {
            additionalArguments.unshift(object);
            message = (this.__name__ + " (" + level + "): ") + this.stringFormat.apply(this, additionalArguments);
          } else if ($.isNumeric(object) || $.type(object) === 'boolean') {
            message = this.__name__ + " (" + level + "): " + (object.toString());
          } else {
            this.log(",--------------------------------------------,");
            this.log(object, force, true);
            this.log("'--------------------------------------------'");
          }
          if (message) {
            if ((((_ref = window.console) != null ? _ref[level] : void 0) == null) || window.console[level] === $.noop()) {
              window.alert(message);
            }
            window.console[level](message);
          }
        }
        return this;
      };

      Tools.prototype.info = function() {
        var additionalArguments, object;
        object = arguments[0], additionalArguments = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

        /*
            Wrapper method for the native console method usually provided
            by interpreter.
        
            **object {Mixed}**    - Any object to print.
        
            Additional arguments are used for string formating.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        return this.log.apply(this, [object, false, false, 'info'].concat(additionalArguments));
      };

      Tools.prototype.debug = function() {
        var additionalArguments, object;
        object = arguments[0], additionalArguments = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

        /*
            Wrapper method for the native console method usually provided
            by interpreter.
        
            **param {Mixed}**     - Any object to print.
        
            Additional arguments are used for string formating.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        return this.log.apply(this, [object, false, false, 'debug'].concat(additionalArguments));
      };

      Tools.prototype.error = function() {
        var additionalArguments, object;
        object = arguments[0], additionalArguments = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

        /*
            Wrapper method for the native console method usually provided
            by interpreter.
        
            **object {Mixed}**    - Any object to print.
        
            Additional arguments are used for string formating.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        return this.log.apply(this, [object, true, false, 'error'].concat(additionalArguments));
      };

      Tools.prototype.critical = function() {
        var additionalArguments, object;
        object = arguments[0], additionalArguments = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

        /*
            Wrapper method for the native console method usually provided
            by interpreter.
        
            **object {Mixed}**    - Any object to print.
        
            Additional arguments are used for string formating.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        return this.log.apply(this, [object, true, false, 'warn'].concat(additionalArguments));
      };

      Tools.prototype.warn = function() {
        var additionalArguments, object;
        object = arguments[0], additionalArguments = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

        /*
            Wrapper method for the native console method usually provided
            by interpreter.
        
            **object {Mixed}**    - Any object to print.
        
            Additional arguments are used for string formating.
        
            **returns {$.Tools}** - Returns the current instance.
         */
        return this.log.apply(this, [object, false, false, 'warn'].concat(additionalArguments));
      };

      Tools.prototype.show = function(object) {

        /*
            Dumps a given object in a human readable format.
        
            **object {Object}**  - Any object to show.
        
            **returns {String}** - Returns the serialized object.
         */
        var output;
        output = '';
        if ($.type(object) === 'string') {
          output = object;
        } else {
          $.each(object, function(key, value) {
            if (value === void 0) {
              value = 'undefined';
            } else if (value === null) {
              value = 'null';
            }
            return output += (key.toString()) + ": " + (value.toString()) + "\n";
          });
        }
        if (!output) {
          output = output.toString();
        }
        return ($.trim(output)) + "\n(Type: \"" + ($.type(object)) + "\")";
      };

      Tools.prototype.getPositionRelativeToViewport = function(delta) {
        var $window, rectangle;
        if (delta == null) {
          delta = {};
        }

        /*
            Determines where current dom node is relative to current view
            port position.
        
            **delta {Object}**   - Allows deltas for "top", "left",
                                   "bottom" and "right" for determining
                                   positions.
        
            **returns {String}** - Returns one of "above", "left", "below",
                                   "right" or "in".
         */
        delta = $.extend({
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        }, delta);
        $window = $(window);
        rectangle = this.$domNode[0].getBoundingClientRect();
        if ((rectangle.top + delta.top) < 0) {
          return 'above';
        }
        if ((rectangle.left + delta.left) < 0) {
          return 'left';
        }
        if ($window.height() < (rectangle.bottom + delta.bottom)) {
          return 'below';
        }
        if ($window.width() < (rectangle.right + delta.right)) {
          return 'right';
        }
        return 'in';
      };

      Tools.prototype.generateDirectiveSelector = function(directiveName) {

        /*
            Generates a directive name corresponding selector string.
        
            **directiveName {String}** - The directive name
        
            **return {String}**        - Returns generated selector
         */
        var delimitedName;
        delimitedName = this.stringCamelCaseToDelimited(directiveName);
        return (delimitedName + ", ." + delimitedName + ", [" + delimitedName + "], ") + ("[data-" + delimitedName + "], [x-" + delimitedName + "]") + (delimitedName.indexOf('-') === -1 ? '' : (", [" + (delimitedName.replace(/-/g, '\\:')) + "], ") + ("[" + (delimitedName.replace(/-/g, '_')) + "]"));
      };

      Tools.prototype.removeDirective = function(directiveName) {

        /*
            Removes a directive name corresponding class or attribute.
        
            **directiveName {String}** - The directive name
        
            **return {DomNode}**       - Returns current dom node
         */
        var delimitedName;
        delimitedName = this.stringCamelCaseToDelimited(directiveName);
        return this.$domNode.removeClass(delimitedName).removeAttr(delimitedName).removeAttr("data-" + delimitedName).removeAttr("x-" + delimitedName).removeAttr(delimitedName.replace('-', ':')).removeAttr(delimitedName.replace('-', '_'));
      };

      Tools.prototype.getNormalizedDirectiveName = function(directiveName) {

        /*
            Determines a normalized camel case directive name
            representation.
        
            **directiveName {String}** - The directive name
        
            **return {String}**        - Returns the corresponding name
         */
        var delimiter, prefix, prefixFound, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        _ref = ['-', ':', '_'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          delimiter = _ref[_i];
          prefixFound = false;
          _ref1 = ['data' + delimiter, 'x' + delimiter];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            prefix = _ref1[_j];
            if (this.stringStartsWith(directiveName, prefix)) {
              directiveName = directiveName.substring(prefix.length);
              prefixFound = true;
              break;
            }
          }
          if (prefixFound) {
            break;
          }
        }
        _ref2 = ['-', ':', '_'];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          delimiter = _ref2[_k];
          directiveName = this.stringDelimitedToCamelCase(directiveName, delimiter);
        }
        return directiveName;
      };

      Tools.prototype.getDirectiveValue = function(directiveName) {

        /*
            Determines a directive attribute value.
        
            **directiveName {String}** - The directive name
        
            **return {String|Null}**   - Returns the corresponding
                                         attribute value or "null" if no
                                         attribute value exists.
         */
        var attributeName, delimitedName, value, _i, _len, _ref;
        delimitedName = this.stringCamelCaseToDelimited(directiveName);
        _ref = [delimitedName, "data-" + delimitedName, "x-" + delimitedName, delimitedName.replace('-', '\\:')];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attributeName = _ref[_i];
          value = this.$domNode.attr(attributeName);
          if (value != null) {
            return value;
          }
        }
      };

      Tools.prototype.sliceDomNodeSelectorPrefix = function(domNodeSelector) {

        /*
            Removes a selector prefix from a given selector. This methods
            searches in the options object for a given
            "domNodeSelectorPrefix".
        
            **domNodeSelector {String}** - The dom node selector to slice.
        
            **return {String}**          - Returns the sliced selector.
         */
        var _ref;
        if ((((_ref = this._options) != null ? _ref.domNodeSelectorPrefix : void 0) != null) && this.stringStartsWith(domNodeSelector, this._options.domNodeSelectorPrefix)) {
          return $.trim(domNodeSelector.substring(this._options.domNodeSelectorPrefix.length));
        }
        return domNodeSelector;
      };

      Tools.prototype.getDomNodeName = function(domNodeSelector) {

        /*
            Determines the dom node name of a given dom node string.
        
            **domNodeSelector {String}** - A given to dom node selector to
                                           determine its name.
        
            **returns {String}**         - Returns the dom node name.
        
            **examples**
        
            >>> $.Tools.getDomNodeName('&lt;div&gt;');
            'div'
        
            >>> $.Tools.getDomNodeName('&lt;div&gt;&lt;/div&gt;');
            'div'
        
            >>> $.Tools.getDomNodeName('&lt;br/&gt;');
            'br'
         */
        return domNodeSelector.match(new RegExp('^<?([a-zA-Z]+).*>?.*'))[1];
      };

      Tools.prototype.grabDomNode = function(domNodeSelectors, wrapperDomNode) {

        /*
            Converts an object of dom selectors to an array of $ wrapped
            dom nodes. Note if selector description as one of "class" or
            "id" as suffix element will be ignored.
        
            **domNodeSelectors {Object}** - An object with dom node
                                            selectors.
        
            **wrapperDomNode {DomNode}**  - A dom node to be the parent or
                                            wrapper of all retrieved dom
                                            nodes.
        
            **returns {Object}**          - Returns all $ wrapped dom nodes
                                            corresponding to given
                                            selectors.
         */
        var domNodes;
        domNodes = {};
        if (domNodeSelectors != null) {
          if (wrapperDomNode != null) {
            wrapperDomNode = $(wrapperDomNode);
            $.each(domNodeSelectors, function(key, value) {
              return domNodes[key] = wrapperDomNode.find(value);
            });
          } else {
            $.each(domNodeSelectors, (function(_this) {
              return function(key, value) {
                var match;
                match = value.match(', *');
                if (match) {
                  $.each(value.split(match[0]), function(key, valuePart) {
                    if (key) {
                      return value += ', ' + _this._grabDomNodeHelper(key, valuePart, domNodeSelectors);
                    } else {
                      return value = valuePart;
                    }
                  });
                }
                return domNodes[key] = $(_this._grabDomNodeHelper(key, value, domNodeSelectors));
              };
            })(this));
          }
        }
        if (this._options.domNodeSelectorPrefix) {
          domNodes.parent = $(this._options.domNodeSelectorPrefix);
        }
        domNodes.window = $(window);
        domNodes.document = $(document);
        return domNodes;
      };

      Tools.prototype.isolateScope = function(scope, prefixesToIgnore) {
        var name, object;
        if (prefixesToIgnore == null) {
          prefixesToIgnore = ['$', '_'];
        }

        /*
            Overwrites all inherited variables from parent scope with
            "undefined".
        
            **scope {Object}**            - A scope where inherited names
                                            will be removed.
        
            **prefixesToIgnore String[]** - Name prefixes to ignore during
                                            deleting names in given scope.
        
            **returns {Object}**          - The isolated scope.
         */
        for (name in scope) {
          object = scope[name];
          if (prefixesToIgnore.indexOf(name.charAt(0)) === -1 && ['this', 'constructor'].indexOf(name) === -1 && !scope.hasOwnProperty(name)) {
            scope[name] = void 0;
          }
        }
        return scope;
      };

      Tools.prototype.determineUniqueScopeName = function(prefix, scope) {
        var uniqueName;
        if (prefix == null) {
          prefix = 'callback';
        }
        if (scope == null) {
          scope = window;
        }

        /*
            Generates a unique function name needed for jsonp requests.
        
            **scope {Object}**   - A scope where the name should be unique.
        
            **returns {String}** - The function name.
         */
        while (true) {
          uniqueName = prefix + window.parseInt(window.Math.random() * window.Math.pow(10, 10));
          if (scope[uniqueName] == null) {
            break;
          }
        }
        return uniqueName;
      };

      Tools.prototype.getMethod = function() {
        var additionalArguments, method, parameter, scope;
        method = arguments[0], scope = arguments[1], additionalArguments = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        if (scope == null) {
          scope = this;
        }

        /*
            Methods given by this method has the plugin scope referenced
            with "this". Otherwise "this" usually points to the object the
            given method was attached to. If "method" doesn't match string
            arguments are passed through "$.proxy()" with "context" setted
            as "scope" or "this" if nothing is provided.
        
            **method {String|Function|Object}** - A method name of given
                                                  scope.
        
            **scope {Object|String}**           - A given scope.
        
            **returns {Mixed}**                 - Returns the given methods
                                                  return value.
         */

        /*
            This following outcomment line would be responsible for a
            bug in yuicompressor.
            Because of declaration of arguments the parser things that
            arguments is a local variable and could be renamed.
            It doesn't care about that the magic arguments object is
            necessary to generate the arguments array in this context.
        
            var arguments = this.argumentsObjectToArray(arguments);
        
            use something like this instead:
        
            var parameter = this.argumentsObjectToArray(arguments);
         */
        parameter = this.argumentsObjectToArray(arguments);
        if ($.type(method) === 'string' && $.type(scope) === 'object') {
          return function() {
            var thisFunction;
            if (!scope[method]) {
              $.error(("Method \"" + method + "\" doesn't exists in ") + ("\"" + scope + "\"."));
            }
            thisFunction = arguments.callee;
            parameter = $.Tools().argumentsObjectToArray(arguments);
            parameter.push(thisFunction);
            return scope[method].apply(scope, parameter.concat(additionalArguments));
          };
        }
        parameter.unshift(scope);
        parameter.unshift(method);
        return $.proxy.apply($, parameter);
      };

      Tools.prototype.identity = function(value) {

        /*
            Implements the identity function.
        
            **value {Object}**   - A value to return.
        
            **returns {Object}** - Returns the given value.
         */
        return value;
      };

      Tools.prototype.invertArrayFilter = function(filter) {

        /*
            Inverted filter helper to inverse each given filter.
        
            **filter {Function}**  - A function that filters an array.
        
            **returns {Function}** - The inverted filter.
         */
        return function(data) {
          var date, filteredData, result, _i, _len;
          if (data) {
            filteredData = filter.apply(this, arguments);
            result = [];
            if (filteredData.length) {
              for (_i = 0, _len = data.length; _i < _len; _i++) {
                date = data[_i];
                if (__indexOf.call(filteredData, date) < 0) {
                  result.push(date);
                }
              }
            } else {
              result = data;
            }
            return result;
          }
          return data;
        };
      };

      Tools.prototype.debounce = function() {
        var additionalArguments, eventFunction, lock, self, thresholdInMilliseconds, timeoutID, waitingCallArguments;
        eventFunction = arguments[0], thresholdInMilliseconds = arguments[1], additionalArguments = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        if (thresholdInMilliseconds == null) {
          thresholdInMilliseconds = 600;
        }

        /*
            Prevents event functions from triggering to often by defining a
            minimal span between each function call. Additional arguments
            given to this function will be forwarded to given event
            function call. The function wrapper returns null if current
            function will be omitted due to debounceing.
        
            **eventFunction** {Function}         - The function to call
                                                   debounced
        
            **thresholdInMilliseconds** {Number} - The minimum time span
                                                   between each function
                                                   call
        
            **returns {Function}**               - Returns the wrapped
                                                   method
         */
        lock = false;
        waitingCallArguments = null;
        self = this;
        timeoutID = null;
        return function() {
          var parameter;
          parameter = self.argumentsObjectToArray(arguments);
          if (lock) {
            waitingCallArguments = parameter.concat(additionalArguments || []);
            null;
          } else {
            lock = true;
            timeoutID = window.setTimeout(((function(_this) {
              return function() {
                lock = false;
                if (waitingCallArguments) {
                  eventFunction.apply(_this, waitingCallArguments);
                  return waitingCallArguments = null;
                }
              };
            })(this)), thresholdInMilliseconds);
            eventFunction.apply(this, parameter.concat(additionalArguments || []));
          }
          return timeoutID;
        };
      };

      Tools.prototype.fireEvent = function() {
        var additionalArguments, callOnlyOptionsMethod, eventHandlerName, eventName, scope;
        eventName = arguments[0], callOnlyOptionsMethod = arguments[1], scope = arguments[2], additionalArguments = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
        if (callOnlyOptionsMethod == null) {
          callOnlyOptionsMethod = false;
        }
        if (scope == null) {
          scope = this;
        }

        /*
            Searches for internal event handler methods and runs them by
            default. In addition this method searches for a given event
            method by the options object. Additional arguments are
            forwarded to respective event functions.
        
            **eventName {String}                - An event name.
        
            **callOnlyOptionsMethod {Boolean}** - Prevents from trying to
                                                  call an internal event
                                                  handler.
        
            **scope {Object}**                  - The scope from where the
                                                  given event handler
                                                  should be called.
        
            **returns {Boolean}**               - Returns "true" if an
                                                  event handler was called
                                                  and "false" otherwise.
         */
        if (!scope) {
          scope = this;
        }
        eventHandlerName = "on" + (this.stringCapitalize(eventName));
        if (!callOnlyOptionsMethod) {
          if (scope[eventHandlerName]) {
            scope[eventHandlerName].apply(scope, additionalArguments);
          } else if (scope["_" + eventHandlerName]) {
            scope["_" + eventHandlerName].apply(scope, additionalArguments);
          }
        }
        if (scope._options && scope._options[eventHandlerName]) {
          scope._options[eventHandlerName].apply(scope, additionalArguments);
          return true;
        }
        return false;
      };

      Tools.prototype.on = function() {

        /*
            A wrapper method for "$.on()". It sets current plugin name as
            event scope if no scope is given. Given arguments are modified
            and passed through "$.on()".
        
            **returns {$}** - Returns $'s grabbed dom node.
         */
        return this._bindHelper(arguments, false);
      };

      Tools.prototype.off = function() {

        /*
            A wrapper method fo "$.off()". It sets current plugin name as
            event scope if no scope is given. Given arguments are modified
            and passed through "$.off()".
        
            **returns {$}** - Returns $'s grabbed dom node.
         */
        return this._bindHelper(arguments, true, 'off');
      };

      Tools.prototype.forEachSorted = function(object, iterator, context) {

        /*
            Iterates given objects own properties in sorted fashion. For
            each key value pair given iterator function will be called with
            value and key as arguments.
        
            **object {Object}**     - Object to iterate.
        
            **iterator {Function}** - Function to execute for each key
                                      value pair. Value will be the first
                                      and key will be the second argument.
        
            **context {Object}**    - The "this" binding for given iterator
                                      function.
        
            **returns {Object[]}**  - List of given sorted keys.
         */
        var key, keys, _i, _len;
        keys = this.sort(object);
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          iterator.call(context, object[key], key);
        }
        return keys;
      };

      Tools.prototype.sort = function(object) {

        /*
            Sort given objects keys.
        
            **object {Object}**    - Object which keys should be sorted.
        
            **returns {Object[]}** - Sorted list of given keys.
         */
        var isArray, key, keys, value;
        isArray = $.isArray(object);
        keys = [];
        for (key in object) {
          value = object[key];
          if (isArray) {
            key = window.parseInt(key);
          }
          if (object.hasOwnProperty(key)) {
            keys.push(key);
          }
        }
        return keys.sort();
      };

      Tools.prototype.equals = function(firstValue, secondValue, properties, deep, exceptionPrefixes, ignoreFunctions) {
        var equal, first, firstIsArray, second, _i, _len, _ref, _ref1;
        if (properties == null) {
          properties = null;
        }
        if (deep == null) {
          deep = -1;
        }
        if (exceptionPrefixes == null) {
          exceptionPrefixes = ['$', '_'];
        }
        if (ignoreFunctions == null) {
          ignoreFunctions = true;
        }

        /*
            Returns true if given items are equal for given property list.
            If property list isn't set all properties will be checked. All
            keys which starts with one of the exception prefixes will be
            omitted.
        
            **firstValue {Mixed}**           - First object to compare.
        
            **secondValue {Mixed}**          - Second object to compare.
        
            **properties {String[]}**        - Property names to check.
                                               Check all if "null" is
                                               selected (default).
        
            **deep {Integer}**               - Recursion depth negative
                                               values means infinitely deep
                                               (default).
        
            **exceptionPrefixes {String[]}** - Property prefixes which
                                               indicates properties to
                                               ignore.
        
            **ignoreFunctions {Boolean}* *   - Indicates weather functions
                                               have to be identical to
                                               interpret is as equal.
                                               If set to "true" two
                                               functions will be assumed to
                                               be equal (default).
        
            **returns {Boolean}**            - "true" if both objects are
                                               equal and "false" otherwise.
         */
        if (ignoreFunctions && $.isFunction(firstValue) && $.isFunction(secondValue) || firstValue === secondValue || this.numberIsNotANumber(firstValue) && this.numberIsNotANumber(secondValue) || firstValue instanceof window.RegExp && secondValue instanceof window.RegExp && firstValue.toString() === secondValue.toString() || firstValue instanceof window.Date && secondValue instanceof window.Date && (window.isNaN(firstValue.getTime()) && window.isNaN(secondValue.getTime()) || !window.isNaN(firstValue.getTime()) && !window.isNaN(secondValue.getTime()) && firstValue.getTime() === secondValue.getTime())) {
          return true;
        }
        if ($.isPlainObject(firstValue) && $.isPlainObject(secondValue) && !(firstValue instanceof window.RegExp || secondValue instanceof window.RegExp) || $.isArray(firstValue) && $.isArray(secondValue)) {
          equal = true;
          _ref = [[firstValue, secondValue], [secondValue, firstValue]];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], first = _ref1[0], second = _ref1[1];
            firstIsArray = $.isArray(first);
            if (firstIsArray && (!$.isArray(second)) || first.length !== second.length) {
              return false;
            }
            $.each(first, (function(_this) {
              return function(key, value) {
                var exceptionPrefix, _j, _len1;
                if (!firstIsArray) {
                  if (!equal || (properties != null) && __indexOf.call(properties, key) < 0) {
                    return;
                  }
                  for (_j = 0, _len1 = exceptionPrefixes.length; _j < _len1; _j++) {
                    exceptionPrefix = exceptionPrefixes[_j];
                    if (_this.stringStartsWith(key.toString(), exceptionPrefix)) {
                      return;
                    }
                  }
                }
                if (deep !== 0 && !_this.equals(value, second[key], properties, deep - 1, exceptionPrefixes)) {
                  return equal = false;
                }
              };
            })(this));
          }
          return equal;
        }
        return false;
      };

      Tools.prototype.argumentsObjectToArray = function(argumentsObject) {

        /*
            Converts the interpreter given magic arguments object to a
            standard array object.
        
            **argumentsObject {Object}** - An argument object.
        
            **returns {Object[]}**       - Returns the array containing all
                                           elements in given arguments
                                           object.
         */
        return window.Array.prototype.slice.call(argumentsObject);
      };

      Tools.prototype.arrayUnique = function(data) {

        /*
            Makes all values in given iterable unique by removing
            duplicates (The first occurrences will be left).
        
            **data {Object}**    - Array like object.
        
            **returns {Object}** - Sliced version of given object.
         */
        var index, result, value;
        result = [];
        for (index in data) {
          value = data[index];
          if (__indexOf.call(result, value) < 0) {
            result.push(value);
          }
        }
        return result;
      };

      Tools.prototype.arrayAggregatePropertyIfEqual = function(data, propertyName, defaultValue) {
        var item, result, _i, _len;
        if (defaultValue == null) {
          defaultValue = '';
        }

        /*
            Summarizes given property of given item list.
        
            **data {Object[]}**       - Array of objects with given
                                        property name.
        
            **propertyName {String}** - Property name to summarize.
        
            **defaultValue {Mixed}**  - Value to return if property values
                                        doesn't match.
         */
        result = defaultValue;
        if ((data != null ? data.length : void 0) && (data[0][propertyName] != null)) {
          result = data[0][propertyName];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            if (item[propertyName] !== result) {
              return defaultValue;
            }
          }
        }
        return result;
      };

      Tools.prototype.arrayDeleteEmptyItems = function(data, propertyNames) {
        var empty, item, propertyName, result, value, _i, _len;
        if (propertyNames == null) {
          propertyNames = [];
        }

        /*
            Deletes every item witch has only empty attributes for given
            property names. If given property names are empty each
            attribute will be considered. The empty string, "null" and
            "undefined" will be interpreted as empty.
        
            **data {Object[]}**          - Data to filter.
        
            **propertyNames {String[]}** - Properties to consider.
        
            **returns {Object[]}**       - Given data without empty items.
         */
        if (data == null) {
          return data;
        }
        result = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          empty = true;
          for (propertyName in item) {
            value = item[propertyName];
            if ((value !== '' && value !== null && value !== (void 0)) && (!propertyNames.length || __indexOf.call(propertyNames, propertyName) >= 0)) {
              empty = false;
              break;
            }
          }
          if (!empty) {
            result.push(item);
          }
        }
        return result;
      };

      Tools.prototype.arrayExtract = function(data, propertyNames) {

        /*
            Extracts all properties from all items wich occur in given
            property names.
        
            **data {Object[]}**          - Data where each item should be
                                           sliced.
        
            **propertyNames {String[]}** - Property names to extract.
        
            **returns {Object[]}**       - Data with sliced items.
         */
        var attributeName, item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          for (attributeName in item) {
            if (__indexOf.call(propertyNames, attributeName) < 0) {
              delete item[attributeName];
            }
          }
        }
        return data;
      };

      Tools.prototype.arrayExtractIfMatches = function(data, regularExpression) {

        /*
            Extracts all values which matches given regular expression.
        
            **data {String[]}**            - Data to filter.
        
            **regularExpression {String}** - Pattern to match for.
        
            **returns {String[]}**         - Filtered data.
         */
        var result;
        result = [];
        $.each(data, function(index, value) {
          if ((new window.RegExp(regularExpression)).test(value)) {
            return result.push(value);
          }
        });
        return result;
      };

      Tools.prototype.arrayExtractIfPropertyExists = function(data, propertyName) {

        /*
            Filters given data if given property is set or not.
        
            **data {Object[]}**       - Data to filter.
        
            **propertyName {String}** - Property name to check for
                                        existence.
        
            **returns {Object[]}**    - Given data without the items which
                                        doesn't have specified property.
         */
        var exists, item, key, result, value, _i, _len;
        if (data && propertyName) {
          result = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            exists = false;
            for (key in item) {
              value = item[key];
              if (key === propertyName && (value != null)) {
                exists = true;
                break;
              }
            }
            if (exists) {
              result.push(item);
            }
          }
          return result;
        }
        return data;
      };

      Tools.prototype.arrayExtractIfPropertyMatches = function(data, propertyPattern) {

        /*
            Extract given data where specified property value matches given
            patterns.
        
            **data {Object[]}**          - Data to filter.
        
            **propertyPattern {Object}** - Mapping of property names to
                                           pattern.
        
            **returns {Object[]}**       - Filtered data.
         */
        var item, key, matches, pattern, result, _i, _len;
        if (data && propertyPattern) {
          result = [];
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            matches = true;
            for (key in propertyPattern) {
              pattern = propertyPattern[key];
              if (!window.RegExp(pattern).test(item[key])) {
                matches = false;
                break;
              }
            }
            if (matches) {
              result.push(item);
            }
          }
          return result;
        }
        return data;
      };

      Tools.prototype.arrayIntersect = function(firstSet, secondSet, keys, strict) {
        var containingData, exists, initialItem, iterateGivenKeys, newItem, _i, _j, _len, _len1;
        if (keys == null) {
          keys = [];
        }
        if (strict == null) {
          strict = true;
        }

        /*
            Determines all objects which exists in "firstSet" and in
            "secondSet". Object key which will be compared are given by
            "keys". If an empty array is given each key will be compared.
            If an object is given corresponding initial data key will be
            mapped to referenced new data key.
        
            **firstSet {Mixed[]}**     - Referenced data to check for.
        
            **secondSet {Mixed[]}**    - Data to check for existence.
        
            **keys {Object|String[]}** - Keys to define equality.
        
            **strict {Boolean}**       - The strict parameter indicates
                                         weather "null" and "undefined"
                                         should be interpreted as equal
                                         (takes only effect if given keys
                                         aren't empty).
        
            **returns {Mixed[]} **     - Data which does exit in given
                                         initial data.
         */
        containingData = [];
        for (_i = 0, _len = firstSet.length; _i < _len; _i++) {
          initialItem = firstSet[_i];
          if ($.isPlainObject(initialItem)) {
            exists = false;
            for (_j = 0, _len1 = secondSet.length; _j < _len1; _j++) {
              newItem = secondSet[_j];
              exists = true;
              iterateGivenKeys = $.isPlainObject(keys) || keys.length;
              if (!iterateGivenKeys) {
                keys = initialItem;
              }
              $.each(keys, function(firstSetKey, secondSetKey) {
                if ($.isArray(keys)) {
                  firstSetKey = secondSetKey;
                } else if (!iterateGivenKeys) {
                  secondSetKey = firstSetKey;
                }
                if (newItem[secondSetKey] !== initialItem[firstSetKey] && (strict || ([null, void 0].indexOf(newItem[secondSetKey]) === -1 || [null, void 0].indexOf(initialItem[firstSetKey]) === -1))) {
                  exists = false;
                  return false;
                }
              });
              if (exists) {
                break;
              }
            }
          } else {
            exists = secondSet.indexOf(initialItem) !== -1;
          }
          if (exists) {
            containingData.push(initialItem);
          }
        }
        return containingData;
      };

      Tools.prototype.arrayMakeRange = function(range, step) {
        var higherBound, index, result;
        if (step == null) {
          step = 1;
        }

        /*
            Creates a list of items within given range.
        
            **range {Integer[]}**   - Array of lower and upper bounds. If
                                      only one value is given lower bound
                                      will be assumed to be zero. Both
                                      integers have to be positive and will
                                      be contained in the resulting array.
        
            **step {Integer}**      - Space between two consecutive values.
        
            **returns {Integer[]}** - Produced array of integers.
         */
        if (range.length === 1) {
          index = 0;
          higherBound = window.parseInt(range[0]);
        } else if (range.length === 2) {
          index = window.parseInt(range[0]);
          higherBound = window.parseInt(range[1]);
        } else {
          return range;
        }
        result = [index];
        while (index <= higherBound - step) {
          index += step;
          result.push(index);
        }
        return result;
      };

      Tools.prototype.arraySumUpProperty = function(data, propertyName) {

        /*
            Sums up given property of given item list.
        
            **data {Object[]}**        - The objects to with the given
                                         property to sum up.
        
            **propertyNames {String}** - Property name to sum up its value.
        
            **returns {Number}**       - The aggregated value.
         */
        var item, result, _i, _len;
        result = 0;
        if (data != null ? data.length : void 0) {
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            item = data[_i];
            result += window.parseFloat(item[propertyName] || 0);
          }
        }
        return result;
      };

      Tools.prototype.arrayAppendAdd = function(item, target, name, checkIfExists) {
        if (checkIfExists == null) {
          checkIfExists = true;
        }

        /*
            Adds an item to another item as array connection (many to one).
        
            **item {Object}**           - Item where the item should be
                                          appended to.
        
            **target {Object}**         - Target to add to given item.
        
            **name {String}**           - Name of the target connection.
        
            **checkIfExists {Boolean}** - Indicates if duplicates are
                                          allowed in resulting list (will
                                          result in linear runtime instead
                                          of constant one).
        
            **returns {Object}** - Item with the appended target.
         */
        if (item.hasOwnProperty(name)) {
          if (!(checkIfExists && __indexOf.call(item[name], target) >= 0)) {
            item[name].push(target);
          }
        } else {
          item[name] = [target];
        }
        return item;
      };

      Tools.prototype.arrayRemove = function(list, target, strict) {
        var index;
        if (strict == null) {
          strict = false;
        }

        /*
            Removes given target on given list.
        
            **list {Object[]}**    - Array to splice.
        
            **target {Object}**    - Target to remove from given list.
        
            **strict {Boolean}**   - Indicates weather to fire an exception
                                     if given target doesn't exists given
                                     list.
        
            **returns {Object[]}** - Item with the appended target.
         */
        if ((list != null) || strict) {
          index = list.indexOf(target);
          if (index === -1) {
            if (strict) {
              throw window.Error("Given target doesn't exists in given list.");
            }
          } else {
            list.splice(index, 1);
          }
        }
        return list;
      };

      Tools.prototype.stringEncodeURIComponent = function(url, encodeSpaces) {

        /*
            This method is intended for encoding *key* or *value* parts of
            query component. We need a custom method because
            "window.encodeURIComponent()" is too aggressive and encodes
            stuff that doesn't have to be encoded per
            "http://tools.ietf.org/html/rfc3986:"
        
            **url {String}**           - URL to encode.
        
            **encodeSpaces {Boolean}** - Indicates weather given url should
                                         encode whitespaces as "+" or
                                         "%20".
        
            **return {String}**        - Encoded given url.
         */
        return window.encodeURIComponent(url).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, encodeSpaces ? '%20' : '+');
      };

      Tools.prototype.stringAddSeparatorToPath = function(path, pathSeparator) {
        if (pathSeparator == null) {
          pathSeparator = '/';
        }

        /*
            Appends a path selector to the given path if there isn't one
            yet.
        
            **path {String}**          - The path for appending a selector.
        
            **pathSeparator {String}** - The selector for appending to
                                         path.
        
            **returns {String}**       - The appended path.
         */
        path = $.trim(path);
        if (path.substr(-1) !== pathSeparator && path.length) {
          return path + pathSeparator;
        }
        return path;
      };

      Tools.prototype.stringHasPathPrefix = function(prefix, path, separator) {
        if (prefix == null) {
          prefix = '/admin';
        }
        if (path == null) {
          path = window.location.pathname;
        }
        if (separator == null) {
          separator = '/';
        }

        /*
            Checks if given path has given path prefix.
        
            **prefix {String}**    - Path prefix to search for.
        
            **path {String}**      - Path to search in.
        
            **separator {String}** - Delimiter to use in path (default is
                                     the posix conform slash).
        
            **returns {Boolean}**  - "true" if given prefix occur and
                                     "false" otherwise.
         */
        if (prefix == null) {
          return false;
        }
        if (!this.stringEndsWith(prefix, separator)) {
          prefix += separator;
        }
        return path === prefix.substring(0, prefix.length - separator.length) || this.stringStartsWith(path, prefix);
      };

      Tools.prototype.stringGetDomainName = function(url, fallback) {
        var result;
        if (url == null) {
          url = window.location.href;
        }
        if (fallback == null) {
          fallback = window.location.hostname;
        }

        /*
            Extracts domain name from given url. If no explicit domain name
            given current domain name will be assumed. If no parameter
            given current domain name will be determined.
        
            **url** {String}      - The url to extract domain from.
        
            **fallback** {String} - The fallback host name if no one exits
                                    in given url (default is current
                                    hostname)
        
            **returns {String}** - Extracted domain.
         */
        result = /^([a-z]*:?\/\/)?([^/]+?)(?::[0-9]+)?(?:\/.*|$)/i.exec(url);
        if (((result != null ? result[2] : void 0) != null) && ((result != null ? result[1] : void 0) != null)) {
          return result[2];
        }
        return fallback;
      };

      Tools.prototype.stringGetPortNumber = function(url, fallback, parameter) {
        var result;
        if (url == null) {
          url = window.location.href;
        }
        if (fallback == null) {
          fallback = null;
        }
        if (parameter == null) {
          parameter = [];
        }

        /*
            Extracts port number from given url. If no explicit port number
            given and no fallback is defined current port number will be
            assumed for local links. For external links 80 will be assumed
            for http protocol or 443 for https.
        
            **url** {String}        - The url to extract port from.
        
            **fallback {String}**   - Fallback port number if no explicit
                                      one was found. Default is derived
                                      from current protocol name.
        
            **parameter {Object[]}** - Additional parameter for checking if
                                       given url is an internal url. Given
                                       url and this parameter will be
                                       forwarded to the
                                       "stringIsInternalURL()" method.
        
            **returns {Integer}** - Extracted port number.
         */
        result = /^(?:[a-z]*:?\/\/[^/]+?)?(?:[^/]+?):([0-9]+)/i.exec(url);
        if ((result != null ? result[1] : void 0) != null) {
          return window.parseInt(result[1]);
        }
        if (fallback !== null) {
          return fallback;
        }
        if (this.stringIsInternalURL.apply(this, [url].concat(parameter)) && window.location.port && window.parseInt(window.location.port)) {
          return window.parseInt(window.location.port);
        }
        if (this.stringGetProtocolName(url) === 'https') {
          return 443;
        } else {
          return 80;
        }
      };

      Tools.prototype.stringGetProtocolName = function(url, fallback) {
        var result;
        if (url == null) {
          url = window.location.href;
        }
        if (fallback == null) {
          fallback = window.location.protocol.substring(0, window.location.protocol.length - 1);
        }

        /*
            Extracts protocol name from given url. If no explicit url is
            given, current protocol will be assumed. If no parameter
            given current protocol number will be determined.
        
            **url** {String}      - The url to extract protocol from.
        
            **fallback** {String} - Fallback port to use if no protocol
                                    exists in given url (default is current
                                    protocol).
        
            **returns {String}**  - Extracted protocol.
         */
        result = /^([a-z]+):\/\//i.exec(url);
        if (result != null ? result[1] : void 0) {
          return result[1];
        }
        return fallback;
      };

      Tools.prototype.stringGetURLVariable = function(keyToGet, input, subDelimiter, hashedPathIndicator, search, hash) {
        var both, data, decodedHash, pathAndSearch, subDelimiterPosition, subHashStartIndex, subSearchStartIndex, variables;
        if (subDelimiter == null) {
          subDelimiter = '$';
        }
        if (hashedPathIndicator == null) {
          hashedPathIndicator = '!';
        }
        if (hash == null) {
          hash = window.location.hash;
        }

        /*
            Read a page's GET URL variables and return them as an
            associative array and preserves ordering.
        
            **keyToGet {String}**            - If key given the
                                               corresponding value is
                                               returned and full object
                                               otherwise.
        
            **input {String}**               - An alternative input to the
                                               url search parameter. If "#"
                                               is given the complete
                                               current hash tag will be
                                               interpreted as url and
                                               search parameter will be
                                               extracted from there. If "&"
                                               is given classical search
                                               parameter and hash parameter
                                               will be taken in account. If
                                               a search string is given
                                               this will be analyzed. The
                                               default is to take given
                                               search part into account.
        
            **subDelimiter {String}**        - Defines which sequence
                                               indicates the start of
                                               parameter in a hash part of
                                               the url.
        
            **hashedPathIndicator {String}** - If defined and given hash
                                               starts with this indicator
                                               given hash will be
                                               interpreted as path
                                               containing search and hash
                                               parts.
        
            **search {String}**              - Search part to take into
                                               account defaults to current
                                               url search part.
        
            **hash {String}**                - Hash part to take into
                                               account defaults to current
                                               url hash part.
        
            **returns {Mixed}**              - Returns the current get
                                               array or requested value. If
                                               requested key doesn't exist
                                               "undefined" is returned.
         */
        if (search == null) {
          if (!hash) {
            hash = '#';
          }
          hash = hash.substring('#'.length);
          if (hashedPathIndicator && this.stringStartsWith(hash, hashedPathIndicator)) {
            subHashStartIndex = hash.indexOf('#');
            if (subHashStartIndex === -1) {
              pathAndSearch = hash.substring(hashedPathIndicator.length);
              hash = '';
            } else {
              pathAndSearch = hash.substring(hashedPathIndicator.length, subHashStartIndex);
              hash = hash.substring(subHashStartIndex);
            }
            subSearchStartIndex = pathAndSearch.indexOf('?');
            if (subSearchStartIndex === -1) {
              search = '';
            } else {
              search = pathAndSearch.substring(subSearchStartIndex);
            }
          } else {
            search = window.location.search;
          }
        }
        if (!input) {
          input = search;
        }
        both = input === '&';
        if (both || input === '#') {
          decodedHash = decodeURIComponent(hash);
          subDelimiterPosition = decodedHash.indexOf(subDelimiter);
          if (subDelimiterPosition === -1) {
            input = '';
          } else {
            input = decodedHash.substring(subDelimiterPosition);
            if (this.stringStartsWith(input, subDelimiter)) {
              input = input.substring(subDelimiter.length);
            }
          }
        } else if (this.stringStartsWith(input, '?')) {
          input = input.substring('?'.length);
        }
        data = input ? input.split('&') : [];
        search = search.substring('?'.length);
        if (both && search) {
          data = data.concat(search.split('&'));
        }
        variables = [];
        $.each(data, function(key, value) {
          var keyValuePair;
          keyValuePair = value.split('=');
          key = window.decodeURIComponent(keyValuePair[0]);
          value = window.decodeURIComponent(keyValuePair[1]);
          variables.push(key);
          return variables[key] = value;
        });
        if (keyToGet != null) {
          return variables[keyToGet];
        }
        return variables;
      };

      Tools.prototype.stringIsInternalURL = function(firstURL, secondURL) {
        var explicitDomainName, explicitPortNumber, explicitProtocolName;
        if (secondURL == null) {
          secondURL = window.location.href;
        }

        /*
            Checks if given url points to another domain than second given
            url. If no second given url provided current url will be
            assumed.
        
            **firstURL {String}**  - URL to check against second url.
        
            **secondURL {String}** - URL to check against first url.
        
            **returns {Boolean}**  - Returns "true" if given first url has
                                     same domain as given second (or
                                     current) or.
         */
        explicitDomainName = this.stringGetDomainName(firstURL, false);
        explicitProtocolName = this.stringGetProtocolName(firstURL, false);
        explicitPortNumber = this.stringGetPortNumber(firstURL, false);
        return (!explicitDomainName || explicitDomainName === this.stringGetDomainName(secondURL)) && (!explicitProtocolName || explicitProtocolName === this.stringGetProtocolName(secondURL)) && (!explicitPortNumber || explicitPortNumber === this.stringGetPortNumber(secondURL));
      };

      Tools.prototype.stringNormalizeURL = function(url) {

        /*
            Normalized given website url.
        
            **url {String}**     - Uniform resource locator to normalize.
        
            **returns {String}** - Normalized result.
         */
        if (url) {
          url = $.trim(url.replace(/^:?\/+/, '').replace(/\/+$/, ''));
          if (this.stringStartsWith(url, 'http')) {
            return url;
          }
          return "http://" + url;
        }
        return '';
      };

      Tools.prototype.stringRepresentURL = function(url) {

        /*
            Represents given website url.
        
            **url {String}**     - Uniform resource locator to represent.
        
            **returns {String}** - Represented result.
         */
        if (url) {
          return $.trim(url.replace(/^(https?)?:?\/+/, '').replace(/\/+$/, ''));
        }
        return '';
      };

      Tools.prototype.stringCamelCaseToDelimited = function(string, delimiter, abbreviations) {
        var abbreviation, abbreviationPattern, escapedDelimiter, _i, _len;
        if (delimiter == null) {
          delimiter = '-';
        }
        if (abbreviations == null) {
          abbreviations = null;
        }

        /*
            Converts a camel cased string to its delimited string version.
        
            **string {String}**          - The string to format.
        
            **delimiter {String}**       - Delimiter string
        
            **abbreviations {String[]}** - Collection of shortcut words to
                                           represent upper cased.
        
            **returns {String}**         - The formatted string.
         */
        if (abbreviations == null) {
          abbreviations = this.abbreviations;
        }
        escapedDelimiter = this.stringGetRegularExpressionValidated(delimiter);
        if (abbreviations.length) {
          abbreviationPattern = '';
          for (_i = 0, _len = abbreviations.length; _i < _len; _i++) {
            abbreviation = abbreviations[_i];
            if (abbreviationPattern) {
              abbreviationPattern += '|';
            }
            abbreviationPattern += abbreviation.toUpperCase();
          }
          string = string.replace(new window.RegExp("(" + abbreviationPattern + ")(" + abbreviationPattern + ")", 'g'), "$1" + delimiter + "$2");
        }
        string = string.replace(new window.RegExp("([^" + escapedDelimiter + "])([A-Z][a-z]+)", 'g'), "$1" + delimiter + "$2");
        return string.replace(new window.RegExp('([a-z0-9])([A-Z])', 'g'), "$1" + delimiter + "$2").toLowerCase();
      };

      Tools.prototype.stringCapitalize = function(string) {

        /*
            Converts a string to its capitalize representation.
        
            **string {String}**  - The string to format.
        
            **returns {String}** - The formatted string.
         */
        return string.charAt(0).toUpperCase() + string.substring(1);
      };

      Tools.prototype.stringDelimitedToCamelCase = function(string, delimiter, abbreviations, preserveWrongFormattedAbbreviations) {
        var abbreviation, abbreviationPattern, escapedDelimiter, stringStartsWithDelimiter, _i, _len;
        if (delimiter == null) {
          delimiter = '-';
        }
        if (abbreviations == null) {
          abbreviations = null;
        }
        if (preserveWrongFormattedAbbreviations == null) {
          preserveWrongFormattedAbbreviations = false;
        }

        /*
            Converts a delimited string to its camel case representation.
        
            **string {String}**          - The string to format.
        
            **delimiter {String}**       - Delimiter string
        
            **abbreviations {String[]}** - Collection of shortcut words to
                                           represent upper cased.
        
            **preserveWrongFormattedAbbreviations {Boolean}**
                                         - If set to "True" wrong formatted
                                           camel case abbreviations will
                                           be ignored.
        
            **returns {String}**         - The formatted string.
         */
        escapedDelimiter = this.stringGetRegularExpressionValidated(delimiter);
        if (abbreviations == null) {
          abbreviations = this.abbreviations;
        }
        if (preserveWrongFormattedAbbreviations) {
          abbreviationPattern = abbreviations.join('|');
        } else {
          abbreviationPattern = '';
          for (_i = 0, _len = abbreviations.length; _i < _len; _i++) {
            abbreviation = abbreviations[_i];
            if (abbreviationPattern) {
              abbreviationPattern += '|';
            }
            abbreviationPattern += (this.stringCapitalize(abbreviation)) + "|" + abbreviation;
          }
        }
        stringStartsWithDelimiter = false;
        if (this.stringStartsWith(string, delimiter)) {
          string = string.substring(delimiter.length);
          stringStartsWithDelimiter = true;
        }
        string = string.replace(new window.RegExp(("(" + escapedDelimiter + ")(" + abbreviationPattern + ")") + ("(" + escapedDelimiter + "|$)"), 'g'), function(fullMatch, before, abbreviation, after) {
          if (fullMatch) {
            return before + abbreviation.toUpperCase() + after;
          }
          return fullMatch;
        });
        string = string.replace(new window.RegExp(escapedDelimiter + "([a-zA-Z0-9])", 'g'), function(fullMatch, firstLetter) {
          if (fullMatch) {
            return firstLetter.toUpperCase();
          }
          return fullMatch;
        });
        if (stringStartsWithDelimiter) {
          string = delimiter + string;
        }
        return string;
      };

      Tools.prototype.stringEndsWith = function(string, searchString) {

        /*
            Checks weather given string ends with given search string.
        
            **string {String}**        - String to search in.
        
            **searchString {String}**  - String to search for.
        
            **returns {String}**       - Returns "true" if given string
                                         ends with given search string
                                         and "false" otherwise.
         */
        return string.length >= searchString.length && string.lastIndexOf(searchString) === string.length - searchString.length;
      };

      Tools.prototype.stringFormat = function() {
        var additionalArguments, string;
        string = arguments[0], additionalArguments = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

        /*
            Performs a string formation. Replaces every placeholder "{i}"
            with the i'th argument.
        
            **string {String}**  - The string to format.
        
            Additional arguments are interpreted as replacements for string
            formating.
        
            **returns {String}** - The formatted string.
         */
        additionalArguments.unshift(string);
        $.each(additionalArguments, function(key, value) {
          return string = string.replace(new RegExp("\\{" + key + "\\}", 'gm'), value);
        });
        return string;
      };

      Tools.prototype.stringGetRegularExpressionValidated = function(string) {

        /*
            Validates the current string for using in a regular expression
            pattern. Special regular expression chars will be escaped.
        
            **string {String}**            - The string to format.
        
            **returns {String}**           - The formatted string.
         */
        return string.replace(/([\\|.*$^+[\]()?\-{}])/g, '\\$1');
      };

      Tools.prototype.stringLowerCase = function(string) {

        /*
            Converts a string to its lower case representation.
        
            **string {String}**  - The string to format.
        
            **returns {String}** - The formatted string.
         */
        return string.charAt(0).toLowerCase() + string.substring(1);
      };

      Tools.prototype.stringMark = function(target, mark, marker, caseSensitiv) {
        var index, offset, searchTarget;
        if (marker == null) {
          marker = '<span class="tools-mark">{1}</span>';
        }
        if (caseSensitiv == null) {
          caseSensitiv = false;
        }

        /*
            Wraps given mark strings in given target with given marker.
        
            **target {String}**         - String to search for marker.
        
            **mark {String}**           - String to search in target for.
        
            **marker {String}**         - HTML template string to mark.
        
            **caseSensitive {Boolean}** - Indicates weather case takes a
                                          role during searching.
        
            **returns {String}**        - Processed result.
         */
        target = $.trim(target);
        mark = $.trim(mark);
        if (target && mark) {
          offset = 0;
          searchTarget = target;
          if (!caseSensitiv) {
            searchTarget = searchTarget.toLowerCase();
          }
          if (!caseSensitiv) {
            mark = mark.toLowerCase();
          }
          while (true) {
            index = searchTarget.indexOf(mark, offset);
            if (index === -1) {
              break;
            } else {
              target = target.substring(0, index) + this.stringFormat(marker, target.substr(index, mark.length)) + target.substring(index + mark.length);
              if (!caseSensitiv) {
                searchTarget = target.toLowerCase();
              }
              offset = index + (marker.length - '{1}'.length) + mark.length;
            }
          }
        }
        return target;
      };

      Tools.prototype.stringMD5 = function(value) {

        /*
            Implements the md5 hash algorithm.
        
            **value {String}**   - Value to calculate md5 hash for.
        
            **returns {String}** - Calculated md5 hash value.
         */
        var AA, BB, CC, DD, S11, S12, S13, S14, S21, S22, S23, S24, S31, S32, S33, S34, S41, S42, S43, S44, a, addUnsigned, b, c, convertToWordArray, d, k, rotateLeft, wordToHex, x, xl, _F, _FF, _G, _GG, _H, _HH, _I, _II;
        rotateLeft = function(lValue, iShiftBits) {
          return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
        };
        addUnsigned = function(lX, lY) {
          var lResult, lX4, lX8, lY4, lY8;
          lX8 = lX & 0x80000000;
          lY8 = lY & 0x80000000;
          lX4 = lX & 0x40000000;
          lY4 = lY & 0x40000000;
          lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
          if (lX4 & lY4) {
            return lResult ^ 0x80000000 ^ lX8 ^ lY8;
          }
          if (lX4 | lY4) {
            if (lResult & 0x40000000) {
              return lResult ^ 0xC0000000 ^ lX8 ^ lY8;
            } else {
              return lResult ^ 0x40000000 ^ lX8 ^ lY8;
            }
          } else {
            return lResult ^ lX8 ^ lY8;
          }
        };
        _F = function(x, y, z) {
          return (x & y) | ((~x) & z);
        };
        _G = function(x, y, z) {
          return (x & z) | (y & (~z));
        };
        _H = function(x, y, z) {
          return x ^ y ^ z;
        };
        _I = function(x, y, z) {
          return y ^ (x | (~z));
        };
        _FF = function(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        };
        _GG = function(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        };
        _HH = function(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        };
        _II = function(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        };
        convertToWordArray = function(value) {
          var lByteCount, lBytePosition, lMessageLength, lNumberOfWords, lNumberOfWords_temp1, lNumberOfWords_temp2, lWordArray, lWordCount;
          lMessageLength = value.length;
          lNumberOfWords_temp1 = lMessageLength + 8;
          lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
          lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
          lWordArray = new Array(lNumberOfWords - 1);
          lBytePosition = 0;
          lByteCount = 0;
          while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | (value.charCodeAt(lByteCount) << lBytePosition);
            lByteCount += 1;
          }
          lWordCount = (lByteCount - (lByteCount % 4)) / 4;
          lBytePosition = (lByteCount % 4) * 8;
          lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
          lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
          lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
          return lWordArray;
        };
        wordToHex = function(lValue) {
          var lByte, lCount, wordToHexValue, wordToHexValueTemp;
          wordToHexValue = '';
          wordToHexValueTemp = '';
          lCount = 0;
          while (lCount <= 3) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            wordToHexValueTemp = "0" + lByte.toString(16);
            wordToHexValue = wordToHexValue + wordToHexValueTemp.substr(wordToHexValueTemp.length - 2, 2);
            lCount += 1;
          }
          return wordToHexValue;
        };
        x = [];
        S11 = 7;
        S12 = 12;
        S13 = 17;
        S14 = 22;
        S21 = 5;
        S22 = 9;
        S23 = 14;
        S24 = 20;
        S31 = 4;
        S32 = 11;
        S33 = 16;
        S34 = 23;
        S41 = 6;
        S42 = 10;
        S43 = 15;
        S44 = 21;
        x = convertToWordArray(value);
        a = 0x67452301;
        b = 0xEFCDAB89;
        c = 0x98BADCFE;
        d = 0x10325476;
        xl = x.length;
        k = 0;
        while (k < xl) {
          AA = a;
          BB = b;
          CC = c;
          DD = d;
          a = _FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
          d = _FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
          c = _FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
          b = _FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
          a = _FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
          d = _FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
          c = _FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
          b = _FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
          a = _FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
          d = _FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
          c = _FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
          b = _FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
          a = _FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
          d = _FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
          c = _FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
          b = _FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
          a = _GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
          d = _GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
          c = _GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
          b = _GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
          a = _GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
          d = _GG(d, a, b, c, x[k + 10], S22, 0x2441453);
          c = _GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
          b = _GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
          a = _GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
          d = _GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
          c = _GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
          b = _GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
          a = _GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
          d = _GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
          c = _GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
          b = _GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
          a = _HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
          d = _HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
          c = _HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
          b = _HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
          a = _HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
          d = _HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
          c = _HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
          b = _HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
          a = _HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
          d = _HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
          c = _HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
          b = _HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
          a = _HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
          d = _HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
          c = _HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
          b = _HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
          a = _II(a, b, c, d, x[k + 0], S41, 0xF4292244);
          d = _II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
          c = _II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
          b = _II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
          a = _II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
          d = _II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
          c = _II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
          b = _II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
          a = _II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
          d = _II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
          c = _II(c, d, a, b, x[k + 6], S43, 0xA3014314);
          b = _II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
          a = _II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
          d = _II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
          c = _II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
          b = _II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
          a = addUnsigned(a, AA);
          b = addUnsigned(b, BB);
          c = addUnsigned(c, CC);
          d = addUnsigned(d, DD);
          k += 16;
        }
        return (wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)).toLowerCase();
      };

      Tools.prototype.stringNormalizePhoneNumber = function(phoneNumber) {

        /*
            Normalizes given phone number for automatic dialing mechanisms.
        
            **phoneNumber {String}** - Number to normalize.
        
            **returns {String}**     - Normalized number.
         */
        if (phoneNumber != null) {
          return ("" + phoneNumber).replace(/[^0-9]*\+/, '00').replace(/[^0-9]+/g, '');
        }
        return '';
      };

      Tools.prototype.stringRepresentPhoneNumber = function(phoneNumber) {

        /*
            Represents given phone number. NOTE: Currently only support
            German phone numbers.
        
            **phoneNumber {String}** - Number to format.
        
            **returns {String}**     - Formatted number.
         */
        if (phoneNumber) {
          phoneNumber = phoneNumber.replace(/^(00|\+)([0-9]+)-([0-9-]+)$/, '+$2 (0) $3');
          phoneNumber = phoneNumber.replace(/^0([1-9][0-9-]+)$/, '+49 (0) $1');
          phoneNumber = phoneNumber.replace(/^([^-]+)-([0-9-]+)$/, '$1 / $2');
          return phoneNumber.replace(/^(.*?)([0-9]+)(-?[0-9]*)$/, function(match, prefix, number, suffix) {
            return prefix + $.trim(number.length % 2 === 0 ? number.replace(/([0-9]{2})/g, '$1 ') : number.replace(/^([0-9]{3})([0-9]+)$/, function(match, triple, rest) {
              return triple + ' ' + $.trim(rest.replace(/([0-9]{2})/g, '$1 '));
            }) + suffix);
          });
        }
        return '';
      };

      Tools.prototype.stringStartsWith = function(string, searchString) {

        /*
            Checks weather given string starts with given search string.
        
            **string {String}**        - String to search in.
        
            **searchString {String}**  - String to search for.
        
            **returns {String}**       - Returns "true" if given string
                                         starts with given search string
                                         and "false" otherwise.
         */
        return string.indexOf(searchString) === 0;
      };

      Tools.prototype.stringDecodeHTMLEntities = function(htmlString) {

        /*
            Decodes all html symbols in text nodes in given html string.
        
            **htmlString {String}** - HTML string to decode.
        
            **returns {String}**    - Decoded html string.
         */
        var textareaDomNode;
        textareaDomNode = window.document.createElement('textarea');
        textareaDomNode.innerHTML = htmlString;
        return textareaDomNode.value;
      };

      Tools.prototype.numberIsNotANumber = function(object) {

        /*
            Checks if given object is java scripts native
            "window.Number.NaN" object.
        
            **object {Mixed}**    - Object to Check.
        
            **returns {Boolean}** - Returns weather given value is not a
                                    number or not.
         */
        return typeof object === 'number' && window.isNaN(object);
      };

      Tools.prototype.numberRound = function(number, digits) {
        if (digits == null) {
          digits = 0;
        }

        /*
            Rounds a given number accurate to given number of digits.
        
            **number {Float}**   - The number to round.
        
            **digits {Integer}** - The number of digits after comma.
        
            **returns {Float}**  - Returns the rounded number.
         */
        return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
      };

      Tools.prototype.sendToIFrame = function(target, url, data, requestType, removeAfterLoad) {
        var form, name, value;
        if (requestType == null) {
          requestType = 'post';
        }
        if (removeAfterLoad == null) {
          removeAfterLoad = false;
        }

        /*
            Send given data to a given iframe.
        
            **target {String|DomNode}**   - Name of the target iframe or
                                            the target iframe itself.
        
            **url {String}**              - URL to send to data to.
        
            **data {Object}**             - Data holding object to send
                                            data to.
        
            **requestType {String}**      - The forms action attribute
                                            value. If nothing is provided
                                            "post" will be used as default.
        
            **removeAfterLoad {Boolean}** - Indicates if created iframe
                                            should be removed right after
                                            load event. Only works if an
                                            iframe object is given instead
                                            of a simple target name.
        
            **returns {String|DomNode}**  - Returns the given target.
         */
        form = $('<form>').attr({
          action: url,
          method: requestType,
          target: $.type(target) === 'string' ? target : target.attr('name')
        });
        for (name in data) {
          value = data[name];
          form.append($('<input>').attr({
            type: 'hidden',
            name: name,
            value: value
          }));
        }
        form.submit().remove();
        return typeof target.on === "function" ? target.on('load', function() {
          if (removeAfterLoad) {
            return target.remove();
          }
        }) : void 0;
      };

      Tools.prototype.sendToExternalURL = function(url, data, requestType, removeAfterLoad) {
        var iFrame;
        if (requestType == null) {
          requestType = 'post';
        }
        if (removeAfterLoad == null) {
          removeAfterLoad = true;
        }

        /*
            Send given data to a temporary created iframe.
        
            **url {String}**              - URL to send to data to.
        
            **data {Object}**             - Data holding object to send
                                            data to.
        
            **requestType {String}**      - The forms action attribute
                                            value. If nothing is provided
                                            "post" will be used as default.
        
            **removeAfterLoad {Boolean}** - Indicates if created iframe
                                            should be removed right after
                                            load event.
        
            **returns {DomNode}**         - Returns the dynamically created
                                            iframe.
         */
        iFrame = $('<iframe>').attr({
          name: this.__name__.charAt(0).toLowerCase() + this.__name__.substring(1) + (new Date).getTime()
        }).hide();
        this.$domNode.after(iFrame);
        return this.sendToIFrame(iFrame, url, data, requestType, removeAfterLoad);
      };

      Tools.prototype._bindHelper = function(parameter, removeEvent, eventFunctionName) {
        var $domNode;
        if (removeEvent == null) {
          removeEvent = false;
        }
        if (eventFunctionName == null) {
          eventFunctionName = 'on';
        }

        /*
            Helper method for attach event handler methods and their event
            handler remove pendants.
        
            **parameter** {Object}**       - Arguments object given to
                                             methods like "bind()" or
                                             "unbind()".
        
            **removeEvent {Boolean}**      - Indicates if "unbind()" or
                                             "bind()" was given.
        
            **eventFunctionName {String}** - Name of function to wrap.
        
            **returns {$}**                - Returns $'s wrapped dom node.
         */
        $domNode = $(parameter[0]);
        if ($.type(parameter[1]) === 'object' && !removeEvent) {
          $.each(parameter[1], (function(_this) {
            return function(eventType, handler) {
              return _this[eventFunctionName]($domNode, eventType, handler);
            };
          })(this));
          return $domNode;
        }
        parameter = this.argumentsObjectToArray(parameter).slice(1);
        if (parameter.length === 0) {
          parameter.push('');
        }
        if (parameter[0].indexOf('.') === -1) {
          parameter[0] += "." + this.__name__;
        }
        if (removeEvent) {
          return $domNode[eventFunctionName].apply($domNode, parameter);
        }
        return $domNode[eventFunctionName].apply($domNode, parameter);
      };

      Tools.prototype._grabDomNodeHelper = function(key, selector, domNodeSelectors) {

        /*
            Converts a dom selector to a prefixed dom selector string.
        
            **key {Integer}**             - Current element in options
                                            array to
                                            grab.
        
            **selector {String}**         - A dom node selector.
        
            **domNodeSelectors {Object}** - An object with dom node
                                            selectors.
        
            **returns {Object}**          - Returns given selector
                                            prefixed.
         */
        var domNodeSelectorPrefix;
        domNodeSelectorPrefix = '';
        if (this._options.domNodeSelectorPrefix) {
          domNodeSelectorPrefix = this._options.domNodeSelectorPrefix + ' ';
        }
        if (!(this.stringStartsWith(selector, domNodeSelectorPrefix) || this.stringStartsWith($.trim(selector), '<'))) {
          domNodeSelectors[key] = domNodeSelectorPrefix + selector;
          return $.trim(domNodeSelectors[key]);
        }
        return $.trim(selector);
      };

      return Tools;

    })();
    $.fn.Tools = function() {
      return (new Tools).controller(Tools, arguments, this);
    };
    $.Tools = function() {
      return (new Tools).controller(Tools, arguments);
    };
    $.Tools["class"] = Tools;
    nativePropFunction = $.fn.prop;
    return $.fn.prop = function(key, value) {

      /*
          JQuery's native prop implementation ignores properties for text
          nodes, comments and attribute nodes.
       */
      var _ref;
      if (arguments.length < 3 && ((_ref = this[0].nodeName) === '#text' || _ref === '#comment') && (this[0][key] != null)) {
        if (arguments.length === 1) {
          return this[0][key];
        }
        if (arguments.length === 2) {
          this[0][key] = value;
          return this;
        }
      }
      return nativePropFunction.apply(this, arguments);
    };
  };

  if (this.require != null) {
    this.require.scopeIndicator = 'jQuery.Tools';
    this.require([['jQuery', 'jquery-2.1.1']], main);
  } else {
    main(this.jQuery);
  }

}).call(this);
