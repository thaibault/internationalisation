<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.compiled.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.compiled.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var internationalisation =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {// #!/usr/bin/env node
// -*- coding: utf-8 -*-
/** @module internationalisation */'use strict';/* !
    region header
    [Project page](http://torben.website/language)

    Copyright Torben Sickert (info["~at~"]torben.website) 16.12.2012

    License
    -------

    This library written by Torben Sickert stand under a creative commons
    naming 3.0 unported license.
    See http://creativecommons.org/licenses/by/3.0/deed.de
    endregion
*/// region imports
Object.defineProperty(exports,'__esModule',{value:true});exports.$=undefined;var _asyncToGenerator2=__webpack_require__(2);var _asyncToGenerator3=_interopRequireDefault(_asyncToGenerator2);var _clientnode=__webpack_require__(3);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:{default:obj}}// NOTE: Only needed for debugging this file.
try{module.require('source-map-support/register')}catch(error){}// endregion
const $=exports.$=_clientnode.$;// region types
// endregion
// region plugins/classes
/**
 * This plugin holds all needed methods to extend a website for
 * internationalisation.
 * @extends tools:Tools
 * @property static:_name - Defines this class name to allow retrieving them
 * after name mangling.
 * @property _options - Options extended by the options given to the
 * initializer method.
 * @property _options.domNodeSelectorPrefix {string} - Selector prefix for all
 * nodes to take into account.
 * @property _options.default {string} - Initial language to use.
 * @property _options.selection {Array.&lt;string>} - List of all supported
 * languages.
 * @property _options.initial {string} - Initial set language (if omitted it
 * will be guest.
 * @property _options.templateDelimiter {Object.&lt;string, string>} - Template
 * delimiter to recognize dynamic content.
 * @property _options.templateDelimiter.pre {string} - Delimiter which
 * introduces a dynamic expression.
 * @property _options.templateDelimiter.post {string} - Delimiter which
 * finishes a dynamic expression.
 * @property _options.fadeEffect {boolean} - Indicates whether a fade effect
 * should be performed.
 * @property _options.textNodeParent {Object.&lt;string, Object>} - Saves
 * informations how parent dom nodes should be animated when containing text
 * will be switched.
 * @property _options.textNodeParent.showAnimation {Object} - Fade in options
 * when a new text should appear.
 * @property _options.textNodeParent.hideAnimation {Object} - Fade out effect
 * options when a text node should be removed before switching them.
 * @property _options.preReplacementLanguagePattern {string} - Pattern to
 * introduce a pre replacement language node.
 * @property _options.replacementLanguagePattern {string} - Text pattern to
 * introduce a post replacement node.
 * @property _options.currentLanguagePattern {string} - Saves a pattern to
 * recognize current language marker.
 * @property _options.replacementDomNodeName {Array.&lt;string>} - Dom node tag
 * name which should be interpreted as a hidden alternate language node
 * (contains text in another language).
 * @property _options.replaceDomNodeNames {Array.&lt;string>} - Tag names which
 * indicates dom nodes which should be replaced.
 * @property _options.toolsLockDescription {string} - Lock description for the
 * locking mechanism provided by the extended tools class.
 * @property _options.languageHashPrefix {string} - Hash prefix to determine
 * current active language by url.
 * @property _options.currentLanguageIndicatorClassName {string} - Class name
 * which marks current language switcher button or link.
 * @property _options.sessionDescription {string} - Name to use for saving
 * preferred language in local storage for current session.
 * @property _options.languageMapping {Object.&lt;string, Array.&lt;string>>} - A
 * mapping of alternate language descriptions.
 * @property _options.onSwitched {Function} - Callback which will be triggered
 * after a language switch has been finished.
 * @property _options.onEnsured {Function} - Callback which will be triggered
 * after a language check has been performed. Needed if some nodes have another
 * language active then others. Useful if only some parts of the dom tree was
 * updated and a full language update isn't required.
 * @property _options.onSwitch {Function} - Callback which should be called
 * before a language switch should be performed.
 * @property _options.onEnsure {Function} - Callback which should be called
 * before a language switch should be ensured.
 * @property _options.domNode {Object.&lt;string, string>} - A mapping of needed
 * internal dom node descriptions to their corresponding selectors.
 * @property currentLanguage - Saves the current language.
 * @property knowntranslations - Saves a mapping of known language strings and
 * their corresponding translations, to boost language replacements or saves
 * redundant replacements in dom tree.
 * @property _$domNodeToFade - Saves all $-extended dom nodes which should be
 * animated.
 * @property _replacements - Saves all text nodes which should be replaced.
 * @property _textNodesWithKnownTranslation - Saves a mapping of known text
 * snippets to their corresponding $-extended dom nodes.
 */class Language extends $.Tools.class{// endregion
// region public methods
// / region special
/* eslint-disable jsdoc/require-description-complete-sentence *//**
     * Initializes the plugin. Current language is set and later needed dom
     * nodes are grabbed.
     * @param options - An options object.
     * @param currentLanguage - Initial language to use.
     * @param knownTranslation - Initial mapping of known language strings and
     * their corresponding translations, to boost language replacements or
     * saves redundant replacements in dom tree.
     * @param $domNodeToFade - Initial dom node to fade.
     * @param replacements - Initial nodes to replace.
     * @param textNodesWithKnownTranslation - Saves a mapping of known text
     * snippets to their corresponding $-extended dom nodes.
     * @returns Returns the current instance wrapped in a promise.
     */// endregion
// region dynamic properties
initialize(options={},currentLanguage='',knownTranslation={},$domNodeToFade=null,replacements=[],textNodesWithKnownTranslation={}){/* eslint-enable jsdoc/require-description-complete-sentence */this.currentLanguage=currentLanguage;this.knownTranslation=knownTranslation;this._$domNodeToFade=$domNodeToFade;this._replacements=replacements;this._textNodesWithKnownTranslation=textNodesWithKnownTranslation;this._options={domNodeSelectorPrefix:'body',default:'enUS',selection:[],initial:null,templateDelimiter:{pre:'{{',post:'}}'},fadeEffect:true,textNodeParent:{showAnimation:[{opacity:1},{duration:'fast'}],hideAnimation:[{opacity:0},{duration:'fast'}]},preReplacementLanguagePattern:'^\\|({1})$',replacementLanguagePattern:'^([a-z]{2}[A-Z]{2}):((.|\\s)*)$',currentLanguagePattern:'^[a-z]{2}[A-Z]{2}$',replacementDomNodeName:['#comment','langreplacement'],replaceDomNodeNames:['#text','langreplace'],toolsLockDescription:'{1}Switch',languageHashPrefix:'language-',currentLanguageIndicatorClassName:'current',sessionDescription:'{1}',languageMapping:{deDE:['de','de_de','de-de','german','deutsch'],enUS:['en','en_us','en-us'],enEN:['en_en','en-en','english'],frFR:['fr','fr_fr','fr-fr','french']},onSwitched:this.constructor.noop,onEnsured:this.constructor.noop,onSwitch:this.constructor.noop,onEnsure:this.constructor.noop,domNode:{knownTranslation:'div.toc'}};super.initialize(options);this._options.preReplacementLanguagePattern=this.constructor.stringFormat(this._options.preReplacementLanguagePattern,this._options.replacementLanguagePattern.substr(1,this._options.replacementLanguagePattern.length-2));this._options.toolsLockDescription=this.constructor.stringFormat(this._options.toolsLockDescription,this.constructor._name);this._options.sessionDescription=this.constructor.stringFormat(this._options.sessionDescription,this.constructor._name);this.$domNodes=this.grabDomNode(this._options.domNode);this.$domNodes.switchLanguageButtons=$(`a[href^="#${this._options.languageHashPrefix}"]`);this._movePreReplacementNodes();this.currentLanguage=this._normalizeLanguage(this._options.default);/*
            NOTE: Only switch current language indicator if we haven't an
            initial language switch which will perform the indicator switch.
        */const newLanguage=this._determineUsefulLanguage();this.on(this.$domNodes.switchLanguageButtons,'click',event=>{event.preventDefault();return this.switch($(event.target).attr('href').substr(this._options.languageHashPrefix.length+1))});if(this.currentLanguage===newLanguage)return $.when(this._switchCurrentLanguageIndicator(newLanguage));return this.switch(newLanguage,true)}// / endregion
/**
     * Switches the current language to given language. This method is mutual
     * synchronized.
     * @param language - New language as string or "true". If set to "true" it
     * indicates that the dom tree should be checked again current language to
     * ensure every text node has right content.
     * @param ensure - Indicates if a switch effect should be avoided.
     * @returns Returns the current instance wrapped in a promise.
     */// region static properties
switch(language,ensure=false){if(language!==true&amp;&amp;this._options.selection.length&amp;&amp;!this._options.selection.includes(language)){this.debug('"{1}" isn\'t one of the allowed languages.',language);return $.when(this)}return this.acquireLock(this._options.toolsLockDescription,()=>{if(language===true){ensure=true;language=this.currentLanguage}else language=this._normalizeLanguage(language);if(ensure&amp;&amp;language!==this._options.default||this.currentLanguage!==language){let actionDescription='Switch to';if(ensure)actionDescription='Ensure';this.debug('{1} "{2}".',actionDescription,language);this._switchCurrentLanguageIndicator(language);this.fireEvent(ensure?'ensure':'switch',true,this,this.currentLanguage,language);this._$domNodeToFade=null;this._replacements=[];const[$lastTextNodeToTranslate,$lastLanguageDomNode]=this._collectTextNodesToReplace(language,ensure);this._ensureLastTextNodeHavingLanguageIndicator($lastTextNodeToTranslate,$lastLanguageDomNode,ensure);return this._handleSwitchEffect(language,ensure)}this.debug('"{1}" is already current selected language.',language);this.releaseLock(this._options.toolsLockDescription);return $.when(this)})}/**
     * Ensures current selected language.
     * @returns Returns the current instance wrapped in a promise.
     */refresh(){return this._movePreReplacementNodes().switch(true)}// / endregion
// region protected methods
/**
     * Depending an activated switching effect this method initialized the
     * effect of replace all text string directly.
     * @param language - New language to use.
     * @param ensure - Indicates if current language should be ensured again
     * every text node content.
     * @returns Returns the current instance wrapped in a promise.
     */_handleSwitchEffect(language,ensure){var _this=this;return(0,_asyncToGenerator3.default)(function*(){const oldLanguage=_this.currentLanguage;if(!ensure&amp;&amp;_this._options.fadeEffect&amp;&amp;_this._$domNodeToFade){yield _this._$domNodeToFade.animate(..._this._options.textNodeParent.hideAnimation).promise();_this._switchLanguage(language);if(_this._$domNodeToFade){yield _this._$domNodeToFade.animate(..._this._options.textNodeParent.showAnimation).promise();yield _this.fireEvent(ensure?'ensured':'switched',true,_this,oldLanguage,language);_this.releaseLock(_this._options.toolsLockDescription)}return _this}_this._switchLanguage(language);yield _this.fireEvent(ensure?'ensured':'switched',true,_this,oldLanguage,language);_this.releaseLock(_this._options.toolsLockDescription);return _this})()}/**
     * Moves pre replacement dom nodes into next dom node behind translation
     * text to use the same translation algorithm for both.
     * @returns Returns the current instance.
     */_movePreReplacementNodes(){const self=this;this.$domNodes.parent.find(':not(iframe)').contents().each(function(){const $this=$(this);const nodeName=$this.prop('nodeName').toLowerCase();if(self._options.replacementDomNodeName.includes(nodeName)){if(!['#comment','#text'].includes(nodeName))// NOTE: Hide replacement dom nodes.
$this.hide();const regularExpression=new RegExp(self._options.preReplacementLanguagePattern);const match=$this.prop('textContent').match(regularExpression);if(match&amp;&amp;match[0]){$this.prop('textContent',$this.prop('textContent').replace(regularExpression,match[1]));let selfFound=false;$this.parent().contents().each(function(){if(selfFound&amp;&amp;$(this).Tools('text').trim()){$this.appendTo(this);return false}if($this[0]===this)selfFound=true})}}});return this}/**
     * Collects all text nodes which should be replaced later.
     * @param language - New language to use.
     * @param ensure - Indicates if the whole dom should be checked again
     * current language to ensure every text node has right content.
     * @returns Return a tuple of last text and language dom node to translate.
     */_collectTextNodesToReplace(language,ensure){let $currentTextNodeToTranslate=null;let $currentLanguageDomNode=null;let $lastTextNodeToTranslate=null;let $lastLanguageDomNode=null;this.knownTranslation={};const self=this;this.$domNodes.parent.find(':not(iframe)').contents().each(function(){const $currentDomNode=$(this);const nodeName=$currentDomNode.prop('nodeName').toLowerCase();if(self._options.replaceDomNodeNames.includes(nodeName.toLowerCase())){// NOTE: We skip empty and nested text nodes
if($currentDomNode.Tools('text').trim()&amp;&amp;$currentDomNode.parents(self._options.replaceDomNodeNames.join()).length===0){$lastLanguageDomNode=self._ensureLastTextNodeHavingLanguageIndicator($lastTextNodeToTranslate,$lastLanguageDomNode,ensure);$currentTextNodeToTranslate=$currentDomNode}}else if($currentTextNodeToTranslate){if(self._options.replacementDomNodeName.includes(nodeName)){let content=$currentDomNode.prop('textContent');if(nodeName!=='#comment')content=$currentDomNode.html();const match=content.match(new RegExp(self._options.replacementLanguagePattern));if(Array.isArray(match)&amp;&amp;match[1]===language){// Save known text translations.
self.knownTranslation[$currentTextNodeToTranslate.Tools('text').trim()]=match[2].trim();self._registerTextNodeToChange($currentTextNodeToTranslate,$currentDomNode,match,$currentLanguageDomNode);$lastTextNodeToTranslate=$currentTextNodeToTranslate;$lastLanguageDomNode=$currentLanguageDomNode;$currentTextNodeToTranslate=null;$currentLanguageDomNode=null}else if($currentDomNode.prop('textContent').match(new RegExp(self._options.currentLanguagePattern)))$currentLanguageDomNode=$currentDomNode;return true}$lastTextNodeToTranslate=null;$lastLanguageDomNode=null;$currentTextNodeToTranslate=null;$currentLanguageDomNode=null}});this._registerKnownTextNodes();return[$lastTextNodeToTranslate,$lastLanguageDomNode]}/**
     * Iterates all text nodes in language known area with known translations.
     * @returns Returns the current instance.
     */_registerKnownTextNodes(){this._textNodesWithKnownTranslation={};const self=this;this.$domNodes.knownTranslation.find(':not(iframe)').contents().each(function(){const $currentDomNode=$(this);// NOTE: We skip empty and nested text nodes.
if(!self._options.replaceDomNodeNames.includes($currentDomNode.prop('nodeName').toLowerCase())&amp;&amp;$currentDomNode.Tools('text').trim()&amp;&amp;$currentDomNode.parents(self._options.replaceDomNodeNames.join()).length===0&amp;&amp;self.knownTranslation.hasOwnProperty($currentDomNode.Tools('text').trim())){self._addTextNodeToFade($currentDomNode);if(self._textNodesWithKnownTranslation.hasOwnProperty(self.knownTranslation[$currentDomNode.prop('textContent').trim()]))self._textNodesWithKnownTranslation[self.knownTranslation[$currentDomNode.prop('textContent').trim()]]=self._textNodesWithKnownTranslation[self.knownTranslation[$currentDomNode.prop('textContent').trim()]].add($currentDomNode);else self._textNodesWithKnownTranslation[self.knownTranslation[$currentDomNode.prop('textContent').trim()]]=$currentDomNode}});return this}/**
     * Normalizes a given language string.
     * @param language - New language to use.
     * @returns Returns the normalized version of given language.
     */_normalizeLanguage(language){for(const otherLanguage in this._options.languageMapping)if(this._options.languageMapping.hasOwnProperty(otherLanguage)){if(!this._options.languageMapping[otherLanguage].includes(otherLanguage.toLowerCase()))this._options.languageMapping[otherLanguage].push(otherLanguage.toLowerCase());if(this._options.languageMapping[otherLanguage].includes(language.toLowerCase()))return otherLanguage}return this._options.default}/**
     * Determines a useful initial language depending on session and browser
     * settings.
     * @returns Returns the determined language.
     */_determineUsefulLanguage(){let result;if(this._options.initial)result=this._options.initial;else if('localStorage'in $.global&amp;&amp;$.global.localStorage.getItem(this._options.sessionDescription)){result=$.global.localStorage.getItem(this._options.sessionDescription);this.debug('Determine "{1}", because of local storage information.',result)}else if('navigator'in $.global&amp;&amp;$.global.navigator.language){result=$.global.navigator.language;this.debug('Determine "{1}", because of browser settings.',result)}else{result=this._options.default;this.debug('Determine "{1}", because of default option.',result)}result=this._normalizeLanguage(result);if(this._options.selection.length&amp;&amp;!this._options.selection.includes(result)){this.debug('"{1}" isn\'t one of the allowed languages. Set language'+' to "{2}".',result,this._options.selection[0]);result=this._options.selection[0]}if('localStorage'in $.global)$.global.localStorage.setItem(this._options.sessionDescription,result);return result}/**
     * Registers a text node to change its content with given replacement.
     * @param $textNode - Text node with content to translate.
     * @returns Returns the current instance.
     */_addTextNodeToFade($textNode){const $parent=$textNode.parent();if(this._$domNodeToFade)this._$domNodeToFade=this._$domNodeToFade.add($parent);else this._$domNodeToFade=$parent;return this}/**
     * Registers a text node to change its content with given replacement.
     * @param $currentTextNodeToTranslate - Text node with content to
     * translate.
     * @param $currentDomNode - A comment node with replacement content.
     * @param match - A matching array of replacement's text content.
     * @param $currentLanguageDomNode - A potential given text node indicating
     * the language of given text node.
     * @returns Returns the current instance.
     */_registerTextNodeToChange($currentTextNodeToTranslate,$currentDomNode,match,$currentLanguageDomNode){this._addTextNodeToFade($currentTextNodeToTranslate);if($currentDomNode)this._replacements.push({$textNodeToTranslate:$currentTextNodeToTranslate,$nodeToReplace:$currentDomNode,textToReplace:match[2],$currentLanguageDomNode:$currentLanguageDomNode});return this}/**
     * Checks if last text has a language indication comment node. This
     * function is called after each parsed dom text node.
     * @param $lastTextNodeToTranslate - Last text to node to check.
     * @param $lastLanguageDomNode - A potential given language indication
     * commend node.
     * @param ensure - Indicates if current language should be ensured again
     * every text node content.
     * @returns Returns the retrieved or newly created language indicating
     * comment node.
     */_ensureLastTextNodeHavingLanguageIndicator($lastTextNodeToTranslate,$lastLanguageDomNode,ensure){if($lastTextNodeToTranslate&amp;&amp;!$lastLanguageDomNode){/*
                Last text node doesn't have a current language indicating dom
                node.
            */let currentLocalLanguage=this.currentLanguage;if(ensure)currentLocalLanguage=this._options.default;$lastLanguageDomNode=$(`&lt;!--${currentLocalLanguage}-->`);$lastTextNodeToTranslate.after($lastLanguageDomNode)}return $lastLanguageDomNode}/**
     * Performs the low level text replacements for switching to given
     * language.
     * @param language - The new language to switch to.
     * @returns Returns the current instance.
     */_switchLanguage(language){for(const replacement of this._replacements){let currentText=replacement.$textNodeToTranslate.html();if(replacement.$textNodeToTranslate.prop('nodeName')==='#text')currentText=replacement.$textNodeToTranslate.prop('textContent');const trimmedText=currentText.trim();if(!this._options.templateDelimiter||!trimmedText.endsWith(this._options.templateDelimiter.post)&amp;&amp;this._options.templateDelimiter.post){// IgnoreTypeCheck
let $currentLanguageDomNode=replacement.$currentLanguageDomNode;if(!replacement.$currentLanguageDomNode){/*
                        Language note wasn't present initially. So we have to
                        determine it now.
                    */$currentLanguageDomNode=$('body');let currentDomNodeFound=false;replacement.$textNodeToTranslate.parent().contents().each(function(){if(currentDomNodeFound){replacement.$currentLanguageDomNode=$currentLanguageDomNode=$(this);return false}if(this===replacement.$textNodeToTranslate[0])currentDomNodeFound=true})}const currentLanguage=$currentLanguageDomNode.prop('textContent');if(language===currentLanguage)this.warn(`Text node "${replacement.textToReplace}" is marked `+`as "${currentLanguage}" and has same translation `+'language as it already is.');const nodeName=replacement.$nodeToReplace.prop('nodeName').toLowerCase();if(nodeName==='#comment')replacement.$textNodeToTranslate.after($(`&lt;!--${currentLanguage}:${currentText}-->`));else replacement.$textNodeToTranslate.after($(`&lt;${nodeName}>${currentLanguage}:${currentText}&lt;/`+`${nodeName}>`).hide());replacement.$textNodeToTranslate.after($(`&lt;!--${language}-->`));if(replacement.$textNodeToTranslate.prop('nodeName')==='#text')replacement.$textNodeToTranslate.prop('textContent',replacement.textToReplace);else replacement.$textNodeToTranslate.html(replacement.textToReplace);$currentLanguageDomNode.remove();replacement.$nodeToReplace.remove()}}// Translate registered known text nodes.
for(const content in this._textNodesWithKnownTranslation)if(this._textNodesWithKnownTranslation.hasOwnProperty(content))this._textNodesWithKnownTranslation[content].prop('textContent',content);if('localStorage'in $.global)$.global.localStorage.setItem(this._options.sessionDescription,language);this.currentLanguage=language;return this}/**
     * Switches the current language indicator in language switch triggered dom
     * nodes.
     * @param language - The new language to switch to.
     * @returns Returns the current instance.
     */_switchCurrentLanguageIndicator(language){$(`a[href="#${this._options.languageHashPrefix}`+`${this.currentLanguage}"].`+this._options.currentLanguageIndicatorClassName).removeClass(this._options.currentLanguageIndicatorClassName);$(`a[href="#${this._options.languageHashPrefix}${language}"]`).addClass(this._options.currentLanguageIndicatorClassName);return this}// endregion
}exports.default=Language;// endregion
Language._name='Language';$.Language=(...parameter)=>$.Tools().controller(Language,parameter);$.Language.class=Language;// region vim modline
// vim: set tabstop=4 shiftwidth=4 expandtab:
// vim: foldmethod=marker foldmarker=region,endregion:
// endregion
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ },
/* 1 */
/***/ function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			configurable: false,
			get: function() { return module.l; }
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			configurable: false,
			get: function() { return module.i; }
		});
		module.webpackPolyfill = 1;
	}
	return module;
}


/***/ },
/* 2 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ }
/******/ ]);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-internationalisation.html">internationalisation</a></li></ul><h3>Classes</h3><ul><li><a href="module-internationalisation-Language.html">Language</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Feb 01 2017 09:18:39 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
